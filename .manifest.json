{
  "title": "BetterLog",
  "files": [
    {
      "id": "ad444597-749a-41b8-881b-5362f5f3496e",
      "name": "Code",
      "type": "server_js",
      "source": "/*************************************************************************\n* Globals\n*********/\nvar sheet_; //the spreadsheet that is appended to\nvar SHEET_MAX_ROWS = 50000; //sheet is cleared and starts again\nvar SHEET_LOG_CELL_WIDTH = 1000; //\nvar SHEET_LOG_HEADER = 'Message layout: Date Time UTC-Offset MillisecondsSinceInvoked LogLevel Message. Use Ctrl↓ (or Command↓) to jump to the last row';\nvar DATE_TIME_LAYOUT = 'yyyy-MM-dd HH:mm:ss:SSS Z'; //http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n\n//ref http://docs.oracle.com/javase/7/docs/api/java/util/logging/Level.html\nvar Level = Object.freeze({\n  OFF:    Number.MAX_VALUE,\n  SEVERE: 1000,\n  WARNING:900,\n  INFO:   800,\n  CONFIG: 700,\n  FINE:   500,\n  FINER:  400,\n  FINEST: 300,\n  ALL: Number.MIN_VALUE});\n\nvar level_ = Level.INFO; //set as default. The log level. We log everything this level or greater.\nvar startTime = new Date();\nvar thisApp_ = this;\nvar counter = 0; \n\n/*************************************************************************\n* public methods\n*********/\n\n/**\n* Allows logging to a Google spreadsheet.\n*\n* @param  {String} optKey    The spreadsheet key (optional). Defaults to the active spreadsheet if available.\n* @param  {String} optSheetName The name of the sheet (optional). Defaults to \"Log\". The sheet is created if needed.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction useSpreadsheet(optKey, optSheetName) {\n  setLogSheet_(optKey, optSheetName);\n  sheet_.getRange(1,1).setValue(SHEET_LOG_HEADER); //in case we need to update\n  rollLogOver_(); //rollover the log if we need to\n  return thisApp_;\n}\n\n/**\n* Logs at the SEVERE level. SEVERE is a message level indicating a serious failure.\n* In general SEVERE messages should describe events that are of considerable importance and \n* which will prevent normal program execution. They should be reasonably intelligible to end users and to system administrators. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction severe(message, optValues) {\n  var lev = Level.SEVERE;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the WARNING level. WARNING is a message level indicating a potential problem.\n* In general WARNING messages should describe events that will be of interest to end users\n* or system managers, or which indicate potential problems. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction warning(message, optValues) {\n  var lev = Level.WARNING;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the INFO level. INFO is a message level for informational messages.\n* Typically INFO messages will be written to the console or its equivalent. So the INFO level \n* should only be used for reasonably significant messages that will make sense to end users and system administrators. \n<h3>Examples:</h3>\n<pre>  \nfunction myFunction() {\n&nbsp; //Best practice for using BetterLog and logging to a spreadsheet: \n&nbsp; // You can add and set the property \"BetterLogLevel\" in File > Project Properties and change it to\n&nbsp; // \"OFF\",\"SEVERE\",\"WARNING\",\"INFO\",\"CONFIG\",\"FINE\",\"FINER\",\"FINEST\" or \"ALL\" at runtime without editing code.\n&nbsp;  Logger = BetterLog.setLevel(ScriptProperties.getProperty('BetterLogLevel')) //defaults to 'INFO' level\n&nbsp; .useSpreadsheet('0AhDqyd_bUCmvdDdGczRlX00zUlBMeGNLeE9SNlJ0VGc'); //automatically rolls over at 50,000 rows\n  \n&nbsp; Logger.log('Messages using Logger.log continue to work');\n  \n&nbsp; Logger.config('The current log level is %s', Logger.getLevel());\n&nbsp; Logger.finer('Entering the \"%s\" function', arguments.callee.name); //only logged if level is FINER, FINEST or ALL.\n    \n&nbsp; Logger.info('Starting my function that does stuff');\n\n&nbsp; //Do our work\n&nbsp; for (var i = 0; i < 5; i++) {\n&nbsp; &nbsp; //do detailed stuff\n&nbsp; &nbsp; Logger.finest('Inside the for loop that does the xyz work. i is currently: %d', i);\n&nbsp; }\n\n&nbsp; Logger.info('My work is complete and I performed %d iterations', i);\n&nbsp; Logger.finer('Returning from the \"%s\" function', arguments.callee.name);\n}\n</pre>\n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction info(message, optValues) {\n  var lev = Level.INFO;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the CONFIG level. CONFIG is a message level for static configuration messages.\n* CONFIG messages are intended to provide a variety of static configuration information, \n* to assist in debugging problems that may be associated with particular configurations. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction config(message, optValues) {\n  var lev = Level.CONFIG;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the FINE level. FINE is a message level providing tracing information.\n* All of FINE, FINER, and FINEST are intended for relatively detailed tracing. \n* The exact meaning of the three levels will vary between subsystems, but in general, \n* FINEST should be used for the most voluminous detailed output, \n* FINER for somewhat less detailed output, and FINE for the lowest volume (and most important) messages.\n* \n* In general the FINE level should be used for information that will be broadly interesting to developers\n* who do not have a specialized interest in the specific subsystem.\n* FINE messages might include things like minor (recoverable) failures. Issues indicating potential performance problems are also worth logging as FINE. T\n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction fine(message, optValues) {\n  var lev = Level.FINE;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the FINER level. FINER indicates a fairly detailed tracing message. \n* By default logging calls for entering, returning, or throwing an exception are traced at this level. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction finer(message, optValues) {\n  var lev = Level.FINER;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the FINEST level. FINEST indicates a highly detailed tracing message. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction finest(message, optValues) {\n  var lev = Level.FINEST;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n/**\n* Logs at the INFO level. INFO is a message level for informational messages.\n* Typically INFO messages will be written to the console or its equivalent. So the INFO level should\n* only be used for reasonably significant messages that will make sense to end users and system administrators. \n*\n* @param  {Object} message    The message to log or an sprintf-like format string (uses Utilities.formatString() internally - see http://www.perlmonks.org/?node_id=20519 as a good reference).\n* @param  {Object...} optValues  If a format string is used in the message, a number of values to insert into the format string.\n* @returns {BetterLog} this object, for chaining\n*/\nfunction log(message, optValues) {\n  return info.apply(this, arguments);\n}\n\n/**\n* Sets the new log level\n*\n* @param  {String} logLevel    The new log level e.g. \"OFF\",\"SEVERE\",\"WARNING\",\"INFO\",\"CONFIG\",\"FINE\",\"FINER\",\"FINEST\" or \"ALL\".\n* @returns {BetterLog} this object, for chaining\n*/\nfunction setLevel(logLevel) {\n  if (typeof logLevel === \"string\") {\n    var logLevel = stringToLevel_(logLevel);\n  }\n  if (logLevel != getLevel_()) {\n    setLevel_(logLevel);\n  }\n  return thisApp_;\n}\n/**\n* Gets the current log level name\n*\n* @returns {String} The name of the current log level e.g. \"OFF\",\"SEVERE\",\"WARNING\",\"INFO\",\"CONFIG\",\"FINE\",\"FINER\",\"FINEST\" or \"ALL\".\n*/\nfunction getLevel() {\n  return levelToString_(getLevel_());\n}\n\n/*************************************************************************\n* @private functions\n********************/\n\n// Returns the string as a Level.\nfunction stringToLevel_(str) {\n  for (var name in Level) {\n    if (name == str) {\n      return Level[name];\n    } \n  } \n}\n\n// Returns the Level as a String\nfunction levelToString_(lvl) {\n  for (var name in Level) {\n    if (Level[name] == lvl)\n      return name;\n  } \n}\n\n//gets the current logging level\nfunction getLevel_() {\n  return level_;\n}\n\n//sets the current logging level\nfunction setLevel_(lvl) {\n  for (var name in Level) {\n    if (Level[name] == lvl) {\n      level_ = lvl;\n      info(\"Log level has been set to \" +  getLevel());\n      break;\n    }\n  }\n}\n\n//checks to see if this level is enabled\nfunction isLoggable_(Level) {\n  if (getLevel_()<=Level) {\n    return true;\n  }\n  return false;\n}\n\n//core logger function\nfunction log_(msg) {\n  counter++;\n  //default console logging (built in with Google Apps Script's View > Logs...)\n  Logger.log(convertUsingDefaultPatternLayout_(msg));\n  //ss logging\n  if (sheet_) {\n    logToSheet_(msg);\n  }\n}\n\n//  rolls over the log if we need to\nfunction rollLogOver_() {\n  var rowCount = sheet_.getLastRow();\n  if (rowCount > SHEET_MAX_ROWS) {\n    //copy the log\n    var ss = sheet_.getParent();\n    var oldLog = ss.copy(ss.getName() + ' as at ' + Utilities.formatDate(new Date(), Session.getScriptTimeZone(), DATE_TIME_LAYOUT));\n    //add current viewers and editors to old log\n    oldLog.addViewers(ss.getViewers());\n    oldLog.addEditors(ss.getEditors());\n    // prep the live log\n    sheet_.deleteRows(2, sheet_.getMaxRows()-2);\n    sheet_.getRange(1,1).setValue(SHEET_LOG_HEADER);\n    //sheet_.appendRow(['Log reached ' + rowCount + ' rows (MAX_ROWS is ' + SHEET_MAX_ROWS + ') and was cleared. Previous log is available here:']);\n    sheet_.getRange(\"A2\").setValue(['Log reached ' + rowCount + ' rows (MAX_ROWS is ' + SHEET_MAX_ROWS + ') and was cleared. Previous log is available here:']);\n    sheet_.appendRow([oldLog.getUrl()]);\n  }\n}\n\n//logs to spreadsheet\nfunction logToSheet_(msg) {\n  //check for rollover every 100 rows logged during one invocation\n  if (counter % 100 === 0) {\n    rollLogOver_();\n  }\n  //sheet_.appendRow([convertUsingSheetPatternLayout_(msg)]);\n  call_(function() {sheet_.appendRow([convertUsingSheetPatternLayout_(msg)]);});\n}\n// convert message to text string\nfunction convertUsingDefaultPatternLayout_(msg) {\n  var dt = Utilities.formatDate(msg.time, Session.getScriptTimeZone(), DATE_TIME_LAYOUT);\n  var message = dt + \" \" + pad_(msg.elapsedTime,6) + \" \" + levelToString_(msg.level) + \" \" + msg.message;\n  return message;\n}\n// convert message to text string\nfunction convertUsingSheetPatternLayout_(msg) {\n  return convertUsingDefaultPatternLayout_(msg);\n}\n//Sets the log sheet, creating one if it doesn't exist\nfunction setLogSheet_(optKey, optSheetName) {\n  var sheetName = optSheetName || \"Log\";\n  var ss = (optKey) ? SpreadsheetApp.openById(optKey) : SpreadsheetApp.getActiveSpreadsheet();\n  var sheets = call_(function() {return ss.getSheets();});\n  for (var i = 0; i < sheets.length; i++) {\n    if (sheets[i].getName() === sheetName) {\n      sheet_ = sheets[i];\n      return;\n    }\n  }\n  sheet_ = ss.insertSheet(sheetName, i);\n  sheet_.deleteColumns(2,sheet_.getMaxColumns()-1);\n  sheet_.getRange(1,1).setValue(SHEET_LOG_HEADER);\n  sheet_.setFrozenRows(1);\n  sheet_.setColumnWidth(1, SHEET_LOG_CELL_WIDTH);\n  info(\"Log created\");\n}\n\n//gets the time since the start of logging\nfunction getElapsedTime_(){\n  return (new Date() - startTime); //milliseconds\n}\n// pads a number with leading zeros\nfunction pad_(n,len) {\n  var s = n.toString();\n  if (s.length < len) {\n    s = ('0000000000' + s).slice(-len);\n  } \n  return s;\n}\nfunction getFormattedStringnewish_(args) {\n  if (args.length === 1) {\n    return args[0];\n  }\n  var afunction = Utilities.formatString;\n  return afunction.apply(this, arguments);\n}\nfunction getFormattedString_(args) {\n  //http://stackoverflow.com/q/15913071/298650\n  if (args.length === 1) return args[0];\n  for (var i = 0, arr = []; i < args.length; ++i) {\n    args[i] = (args[i] === '')? args[i] : args[i]||'undefined'; //undefined become strings 'undefined'\n    arr.push('args[' + i + ']');\n  }\n  var result = eval('Utilities.formatString(' + arr.join() + ')');\n  return result;\n}\nfunction getFormattedStringA_(args) {\n  //(typeof message == 'string' || message instanceof String) : Utilities.formatString.apply(this, arguments),\n  /*if (args.length === 1) {\n    return args[0];\n  }*/\n\n  return Utilities.formatString.apply(this, arguments);\n}\nfunction test(message, optValues) {\n  var lev = Level.INFO;\n  if (isLoggable_(lev)) {\n    log_({\"message\": (typeof message == 'string' || message instanceof String) ? Utilities.formatString.apply(this, arguments) : message,\n          \"level\": lev,\n          \"time\": new Date(),\n          \"elapsedTime\": getElapsedTime_()\n         });\n  }\n  return thisApp_;\n}\n\n//copy version 10 lib GASRetry 'MGJu3PS2ZYnANtJ9kyn2vnlLDhaBgl_dE' (changed function name and log line)\nfunction call_(func, optLoggerFunction) {\n  for (var n=0; n<6; n++) {\n    try {\n      return func();\n    } catch(e) {\n      if (optLoggerFunction) {optLoggerFunction(\"call_ \" + n + \": \" + e)}\n      if (n == 5) {\n        throw e;\n      } \n      Utilities.sleep((Math.pow(2,n)*1000) + (Math.round(Math.random() * 1000)));\n    }    \n  }\n}"
    }
  ],
  "id": "1DSyxam1ceq72bMHsE6aOVeOl94X78WCwiYPytKi7chlg4x5GqiNXSw0l",
  "path": "/Users/peter/GitHub/BetterLog"
}